<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Simulador de Agujero Negro – Kerr Relativista</title>
<style>
    body { margin:0; overflow:hidden; background:#000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    canvas { display:block; }
    #info {
        position:absolute; top:15px; left:15px;
        color:#9cf; font-size:12px;
        background:rgba(10,10,30,.7);
        padding:10px 15px; border-radius:8px;
        backdrop-filter: blur(8px);
        pointer-events: none;
        border: 1px solid rgba(153, 204, 255, 0.2);
    }
</style>
</head>
<body>

<canvas id="canvas"></canvas>
<div id="info">
    <strong>Simulación Kerr</strong><br>
    FPS: <span id="fps">0</span><br>
    Partículas: <span id="activeParticles">0</span>
</div>

<script>
/* ================= CANVAS ================= */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

/* ================= CONSTANTES Y PARÁMETROS ================= */
const G = 1;
const c = 1;
const scale = 8; // Aumentado para mejor visibilidad

let M = 25;
let a = 0.9; // Rotación (0 a 1)
let viewAngle = 75;

let rs, rPlus, rISCO, rPhoton;
let centerX, centerY;

/* ================= MÉTRICAS ================= */
function calculateMetrics() {
    centerX = canvas.width / 2;
    centerY = canvas.height / 2;
    
    rs = 2 * G * M;
    const term = Math.sqrt(Math.max(0, 1 - a * a));
    rPlus = G * M * (1 + term);

    const Z1 = 1 + Math.pow(1 - a * a, 1 / 3) * (Math.pow(1 + a, 1 / 3) + Math.pow(1 - a, 1 / 3));
    const Z2 = Math.sqrt(3 * a * a + Z1 * Z1);
    rISCO = G * M * (3 + Z2 - Math.sqrt(Math.max(0, (3 - Z1) * (3 + Z1 + 2 * Z2))));
    rPhoton = 1.5 * rs;
}

/* ================= PARTÍCULAS ================= */
class Particle {
    constructor() { this.reset(); }

    reset() {
        const u = Math.random();
        // Aparecen cerca del ISCO (Innermost Stable Circular Orbit)
        this.r = rISCO + Math.pow(u, 0.5) * rISCO * 5;
        this.theta = Math.random() * Math.PI * 2;
        this.z = (Math.random() - 0.5) * this.r * 0.2;
        this.size = 0.5 + Math.random() * 1.5;
        this.brightness = 0.4 + Math.random() * 0.6;
    }

    update(dt) {
        // Velocidad angular (Kepleriana + arrastre de marco de Kerr)
        const omega = Math.sqrt(G * M / Math.pow(this.r, 3));
        const frameDragging = (a * rs) / (this.r * this.r * this.r); 
        this.theta += (omega + frameDragging) * dt;

        // Caída gradual hacia el horizonte
        this.r -= 0.005 * dt * (rISCO / this.r);
        
        if (this.r < rPlus * 1.1) this.reset();
    }

    draw() {
        const angleRad = viewAngle * Math.PI / 180;
        const cosA = Math.cos(angleRad);

        // Proyección 3D simple
        const x = centerX + Math.cos(this.theta) * this.r * scale;
        const y = centerY + (Math.sin(this.theta) * this.r * cosA + this.z) * scale;

        // Intensidad basada en distancia (aproximación térmica)
        const temp = Math.pow(rISCO / this.r, 0.5);
        let r = 255;
        let g = 140 + temp * 60;
        let b = 50 + temp * 100;

        // Redshift gravitacional simple
        const redshift = Math.sqrt(Math.max(0.1, 1 - rs / this.r));
        r *= redshift; g *= redshift; b *= redshift;

        ctx.fillStyle = `rgba(${r},${g},${b},${this.brightness})`;
        ctx.beginPath();
        ctx.arc(x, y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

let particles = [];
function initParticles() {
    particles = [];
    for (let i = 0; i < 3000; i++) particles.push(new Particle());
}

/* ================= DIBUJO DE ESCENA ================= */
const stars = Array.from({ length: 200 }, () => ({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    s: Math.random() * 1.5
}));

function drawStars() {
    ctx.fillStyle = "#fff";
    stars.forEach(s => {
        ctx.globalAlpha = 0.2 + Math.random() * 0.3;
        ctx.fillRect(s.x, s.y, s.s, s.s);
    });
    ctx.globalAlpha = 1;
}

function drawEventHorizon() {
    const R = rPlus * scale * 1.2; 
    const angle = viewAngle * Math.PI / 180;
    const flatten = Math.cos(angle);

    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.scale(1, flatten);

    // Sombra del horizonte
    const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, R);
    grad.addColorStop(0.8, "black");
    grad.addColorStop(1, "rgba(0,0,0,0.8)");

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(0, 0, R, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
}

/* ================= LOOP DE ANIMACIÓN ================= */
let lastTime = 0;
function animate(currentTime) {
    const dt = (currentTime - lastTime) / 16.67 || 1;
    lastTime = currentTime;

    // Fondo con estela (Motion Blur)
    ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawStars();

    // Dibujar partículas
    particles.forEach(p => {
        p.update(dt);
        p.draw();
    });

    drawEventHorizon();

    // Actualizar UI
    if (Math.random() > 0.9) {
        document.getElementById("fps").innerText = Math.round(60 / dt);
        document.getElementById("activeParticles").innerText = particles.length;
    }

    requestAnimationFrame(animate);
}

/* ================= INIT ================= */
calculateMetrics();
initParticles();
requestAnimationFrame(animate);
</script>

</body>
</html>
