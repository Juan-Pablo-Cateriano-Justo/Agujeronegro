<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Simulador de Agujero Negro – Kerr Relativista</title>
<style>
    body { margin:0; overflow:hidden; background:#000; font-family:Segoe UI; }
    canvas { display:block; }
    #info {
        position:absolute; top:15px; left:15px;
        color:#9cf; font-size:11px;
        background:rgba(10,10,30,.7);
        padding:8px 12px; border-radius:6px;
        backdrop-filter: blur(8px);
    }
</style>
</head>
<body>

<canvas id="canvas"></canvas>
<div id="info">
    FPS: <span id="fps">0</span><br>
    Partículas: <span id="activeParticles">0</span>
</div>

<script>
/* ================= CANVAS ================= */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
canvas.width = innerWidth;
canvas.height = innerHeight;

const centerX = canvas.width / 2;
const centerY = canvas.height / 2;

/* ================= CONSTANTES ================= */
const G = 1;
const c = 1;
const scale = 2;

/* ================= PARÁMETROS ================= */
let M = 20;
let a = 0.8;
let viewAngle = 80;

let rs, rPlus, rISCO, rPhoton;

/* ================= MÉTRICAS ================= */
function calculateMetrics() {
    rs = 2 * G * M;

    const term = Math.sqrt(1 - a * a);
    rPlus = G * M * (1 + term);

    const Z1 = 1 + Math.pow(1 - a * a, 1 / 3) *
        (Math.pow(1 + a, 1 / 3) + Math.pow(1 - a, 1 / 3));
    const Z2 = Math.sqrt(3 * a * a + Z1 * Z1);
    rISCO = G * M * (3 + Z2 - Math.sqrt((3 - Z1) * (3 + Z1 + 2 * Z2)));

    rPhoton = 1.5 * rs;
}

/* ================= PARTÍCULAS ================= */
class Particle {
    constructor() { this.reset(); }

    reset() {
        const u = Math.random();
        this.r = rISCO + Math.pow(u, 0.4) * rISCO * 4;
        this.theta = Math.random() * Math.PI * 2;
        this.z = (Math.random() - 0.5) * this.r * 0.15;
        this.size = 0.8 + Math.random() * 1.5;
        this.brightness = 0.3 + Math.random() * 0.7;
    }

    update(dt) {
        const omega = Math.sqrt(G * M / Math.pow(this.r, 3));
        const frameDragging = a * rs / this.r;
        this.theta += (omega + frameDragging) * dt;

        this.r -= 0.0008 * dt * (rISCO / this.r);
        if (this.r < rPlus) this.reset();
    }

    temperature() {
        const spiral = 1 + 0.35 * Math.sin(this.theta * 3 + this.r * 0.05);
        return Math.pow((rISCO * 5) / this.r, 0.75) * spiral;
    }

    draw() {
        const angleRad = viewAngle * Math.PI / 180;
        const cosA = Math.cos(angleRad);

        const x = centerX + Math.cos(this.theta) * this.r * scale;
        const y = centerY + (Math.sin(this.theta) * this.r * cosA + this.z) * scale;

        let temp = this.temperature();

        let r = 255;
        let g = 160 + temp * 40;
        let b = 80 + temp * 30;

        const redshift = Math.sqrt(Math.max(0.05, 1 - rs / this.r));
        r *= redshift; g *= redshift; b *= redshift;

        const grad = ctx.createRadialGradient(x, y, 0, x, y, this.size * 3);
        grad.addColorStop(0, `rgba(${r},${g},${b},${this.brightness})`);
        grad.addColorStop(1, `rgba(${r},${g},${b},0)`);

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, this.size * 2.5, 0, Math.PI * 2);
        ctx.fill();
    }
}

let particles = [];
function initParticles() {
    particles = [];
    for (let i = 0; i < 4000; i++) particles.push(new Particle());
}

/* ================= FONDO ================= */
const stars = Array.from({ length: 300 }, () => ({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    s: Math.random() * 1.2
}));

function drawStars() {
    ctx.fillStyle = "#fff";
    stars.forEach(s => {
        ctx.globalAlpha = 0.3 + Math.random() * 0.4;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.s, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.globalAlpha = 1;
}

/* ================= LENTE ================= */
function drawGravitationalLensing() {
    const ring = rPhoton * scale;
    const grad = ctx.createRadialGradient(centerX, centerY, ring * 0.85,
                                          centerX, centerY, ring * 1.15);
    grad.addColorStop(0, "rgba(120,160,255,0)");
    grad.addColorStop(0.5, "rgba(120,160,255,0.35)");
    grad.addColorStop(1, "rgba(120,160,255,0)");

    ctx.strokeStyle = grad;
    ctx.lineWidth = 8;
    ctx.beginPath();
    ctx.arc(centerX, centerY, ring, 0, Math.PI * 2);
    ctx.stroke();
}

/* ================= HORIZONTE KERR ================= */
function drawEventHorizon() {
    const baseR = rPlus * scale * 2.8 * 1.2;
    const angleRad = viewAngle * Math.PI / 180;

    ctx.fillStyle = "#000";
    ctx.beginPath();

    for (let i = 0; i <= 360; i++) {
        const t = i * Math.PI / 180;
        const drag = a * Math.cos(t) * 0.35;
        const r = baseR * (1 + drag);
        const x = centerX + r * Math.cos(t);
        const y = centerY + r * Math.sin(t) * Math.cos(angleRad);

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = "rgba(255,100,0,0.4)";
    ctx.lineWidth = 3;
    ctx.stroke();
}

/* ================= LOOP ================= */
let last = performance.now();
let fpsC = 0, fpsT = last;

function animate(t) {
    const dt = Math.min((t - last) / 1000, 0.05);
    last = t;

    ctx.fillStyle = "rgba(5,5,15,0.9)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawStars();
    drawGravitationalLensing();

    particles.sort((a, b) => b.z - a.z);
    particles.forEach(p => { p.update(dt); p.draw(); });

    drawEventHorizon();

    ctx.globalCompositeOperation = "lighter";
    ctx.globalAlpha = 0.08;
    ctx.drawImage(canvas, 0, 0);
    ctx.globalCompositeOperation = "source-over";
    ctx.globalAlpha = 1;

    fpsC++;
    if (t - fpsT > 1000) {
        document.getElementById("fps").textContent = fpsC;
        document.getElementById("activeParticles").textContent = particles.length;
        fpsC = 0; fpsT = t;
    }

    requestAnimationFrame(animate);
}

/* ================= INIT ================= */
calculateMetrics();
initParticles();
animate(performance.now());
</script>

</body>
</html>
